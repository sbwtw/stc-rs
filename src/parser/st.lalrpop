use crate::ast::*;
use crate::parser::lexer::{self, LiteralType, StString};
use crate::parser::Tok;

grammar;

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum Tok {
        "." => Tok::Access,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Multiply,
        "/" => Tok::Division,
        "(" => Tok::LeftParentheses,
        ")" => Tok::RightParentheses,
        "," => Tok::Comma,
        ";" => Tok::Semicolon,
        ":=" => Tok::Assign,
        ":" => Tok::Colon,
        "IF" => Tok::If,
        "THEN" => Tok::Then,
        "ELSE" => Tok::Else,
        "ELSEIF" => Tok::ElseIf,
        "END_IF" => Tok::EndIf,
        "Function" => Tok::Function,
        "Int" => Tok::Int,
        "Literal" => Tok::Literal(<LiteralType>),
        "Identifier" => Tok::Identifier(<StString>),
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub StFunction = StatementList;

StatementList: Box<dyn Statement> = {
    Statement+ => Box::new(StatementList(<>))
}

pub Statement: Box<dyn Statement> = {
    <e:Expr> ";" => Box::new(ExprStatement::new(e)),
    "IF" <cond: Expr> "THEN" <then_ctrl: StatementList> "END_IF" => Box::new(IfStatement::from_then(<>)),
    "IF" <cond: Expr> "THEN" <then_ctrl: StatementList> "ELSE" <else_ctrl: StatementList> "END_IF" => Box::new(IfStatement::from_then_else(<>)),
    "IF" <cond: Expr> "THEN" <then_ctrl: StatementList> <else_if_list: ElseIfStatementList> "ELSE" <else_ctrl: StatementList> "END_IF" => Box::new(IfStatement::from_then_elseif_else(<>)),
}

ElseIfStatementList: Vec<ElseIfStatement> = {
    ElseIfStatement+ => <>
}

ElseIfStatement: ElseIfStatement = {
    "ELSEIF" <cond: Expr> "THEN" <then_ctrl: StatementList> => ElseIfStatement::from_then(<>),
}

Expr: Box<dyn Expression> = {
    <lhs: Expr> ":=" <rhs: OpExpr> => Box::new(AssignExpression::new(<>)),
    OpExpr,
};

ExprOp: Tok = {
    "+" => Tok::Plus,
    "-" => Tok::Minus,
};

OpExpr: Box<dyn Expression> = {
    <e1: OpExpr> <op: ExprOp> <e2: Factor> => Box::new(OperatorExpression::new(op, vec![e1, e2])),
    Factor,
}

Factor: Box<dyn Expression> = {
    <e1: Factor> <op: FactorOp> <e2: UnaryFactor> => Box::new(OperatorExpression::new(op, vec![e1, e2])),
    UnaryFactor,
};

FactorOp: Tok = {
    "*" => Tok::Multiply,
    "/" => Tok::Division,
};

UnaryFactor: Box<dyn Expression> = {
    <op: UnaryOp> <e: CompoFactor> => Box::new(OperatorExpression::new(op, vec![e])),
    CompoFactor,
}

CompoFactor: Box<dyn Expression> = {
    <left: CompoFactor> "." <right: Term> => Box::new(CompoAccessExpression::new(<>)),
    Term,
}

UnaryOp: Tok = {
    "-" => Tok::Minus,
};

Term: Box<dyn Expression> = {
    "Literal" => Box::new(LiteralExpression::new(<>)),
    "Identifier" => Box::new(Variable::new(<>)),
    "(" <Expr> ")",
};

/// Declarations
pub FunctionDeclaration: Box<dyn Declaration> = {
    "Function" <name: "Identifier"> ":" => Box::new(FunctionDeclaration::with_name(<>)),
    "Function" <name: "Identifier"> ":" <ty: Type> => Box::new(FunctionDeclaration::with_name_type(<>)),
}

Type: Box<dyn Type> = {
    "Int" => Box::new(IntType::new()),
    "Identifier" => Box::new(UserType::from_name(<>)),
}

VariableDeclareStatement: Variable = {
    <ident: "Identifier"> ":" <ty: Type> ";"  => Variable::with_type(<>),
}

MultiVariableDeclareStatement: Vec<Variable> = {
    <ident_list: Comma<"Identifier">> ":" <ty: Type> ";" => Variable::multiple_variable_with_type(<>),
}