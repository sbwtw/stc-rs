use crate::ast::*;
use crate::parser::lexer::{self, LiteralValue, StString};
use crate::parser::Tok;
use std::sync::Arc;

grammar;

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum Tok {
        "." => Tok::Access,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Multiply,
        "/" => Tok::Division,
        "(" => Tok::LeftParentheses,
        ")" => Tok::RightParentheses,
        "," => Tok::Comma,
        ";" => Tok::Semicolon,
        ":=" => Tok::Assign,
        ":" => Tok::Colon,
        "IF" => Tok::If,
        "THEN" => Tok::Then,
        "ELSE" => Tok::Else,
        "ELSEIF" => Tok::ElseIf,
        "END_IF" => Tok::EndIf,
        "FUNCTION" => Tok::Function,
        "END_FUNCTION" => Tok::EndFunction,
        "PROGRAM" => Tok::Program,
        "END_PROGRAM" => Tok::EndProgram,
        "VAR" => Tok::Var,
        "VAR_GLOBAL" => Tok::VarGlobal,
        "VAR_INPUT" => Tok::VarInput,
        "VAR_INOUT" => Tok::VarInOut,
        "VAR_OUTPUT" => Tok::VarOutput,
        "VAR_TEMP" => Tok::VarTemp,
        "VAR_STAT" => Tok::VarStat,
        "END_VAR" => Tok::EndVar,
        "RETAIN" => Tok::Retain,
        "PERSISTENT" => Tok::Persistent,
        "TYPE" => Tok::Type,
        "END_TYPE" => Tok::EndType,
        "INT" => Tok::Int,
        "LITERAL" => Tok::Literal(<LiteralValue>),
        "IDENTIFIER" => Tok::Identifier(<StString>),
    }
}

/// Comma split values
Comma<T>: Vec<T> = {
    <v:(<T> ",")+> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

/// Top-level ST function
pub StFunction = StatementList;

/// ST Statements
StatementList: Box<dyn Statement> = {
    Statement+ => Box::new(StatementList::new(<>))
}

/// Single statement
pub Statement: Box<dyn Statement> = {
    DeclarationStatement,
    <e:Expr> ";" => Box::new(ExprStatement::new(e)),
    "IF" <cond: Expr> "THEN" <then_ctrl: StatementList> "END_IF" => Box::new(IfStatement::from_then(<>)),
    "IF" <cond: Expr> "THEN" <then_ctrl: StatementList> "ELSE" <else_ctrl: StatementList> "END_IF" => Box::new(IfStatement::from_then_else(<>)),
    "IF" <cond: Expr> "THEN" <then_ctrl: StatementList> <else_if_list: ElseIfStatementList> "ELSE" <else_ctrl: StatementList> "END_IF" => Box::new(IfStatement::from_then_elseif_else(<>)),
}

/// ElseIf list wrap in if statement
ElseIfStatementList: Vec<ElseIfStatement> = {
    ElseIfStatement+
}

/// Single ElseIf statement
ElseIfStatement: ElseIfStatement = {
    "ELSEIF" <cond: Expr> "THEN" <then_ctrl: StatementList> => ElseIfStatement::from_then(<>),
}

/// Expression
Expr: Box<dyn Expression> = {
    <lhs: Expr> ":=" <rhs: OpExpr> => Box::new(AssignExpression::new(<>)),
    OpExpr,
};

/// Low-priority op
ExprOp: Tok = {
    "+" => Tok::Plus,
    "-" => Tok::Minus,
};

/// Low-priority op expression
OpExpr: Box<dyn Expression> = {
    <e1: OpExpr> <op: ExprOp> <e2: Factor> => Box::new(OperatorExpression::new(op, vec![e1, e2])),
    Factor,
}

/// High-priority factor
Factor: Box<dyn Expression> = {
    <e1: Factor> <op: FactorOp> <e2: UnaryFactor> => Box::new(OperatorExpression::new(op, vec![e1, e2])),
    UnaryFactor,
};

/// High-priority op
FactorOp: Tok = {
    "*" => Tok::Multiply,
    "/" => Tok::Division,
};

/// Top priority unary factor
UnaryFactor: Box<dyn Expression> = {
    <op: UnaryOp> <e: CompoFactor> => Box::new(OperatorExpression::new(op, vec![e])),
    CompoFactor,
}

/// Variable compo access factor
CompoFactor: Box<dyn Expression> = {
    <left: CompoFactor> "." <right: Term> => Box::new(CompoAccessExpression::new(<>)),
    Term,
}

/// Top priority unary op
UnaryOp: Tok = {
    "-" => Tok::Minus,
};

/// terminals in expression
Term: Box<dyn Expression> = {
    "LITERAL" => Box::new(LiteralExpression::new(<>)),
    "IDENTIFIER" => Box::new(Variable::new(<>)),
    "(" <Expr> ")",
};

/// Declaration statement
pub DeclarationStatement: Box<dyn Statement> = {
    Declaration => Box::new(DeclarationStatement::new(<>)),
}

/// Declarations
pub Declaration: Box<dyn Declaration> = {
    "TYPE" <ty: TypeDeclaration> "END_TYPE" => ty,
    "FUNCTION" <name: "IDENTIFIER"> ":" <ty: Type?> <v: VariableDeclareFactor?> "END_FUNCTION" => Box::new(FunctionDeclaration::new(name, DeclareClass::Function, ty, v.unwrap_or(vec![]))),
    "PROGRAM" <name: "IDENTIFIER"> ":" <ty: Type?> <v: VariableDeclareFactor?> "END_PROGRAM" => Box::new(FunctionDeclaration::new(name, DeclareClass::Program, ty, v.unwrap_or(vec![]))),
}

TypeDeclaration: Box<dyn Declaration> = {
    <name: "IDENTIFIER"> ":" "(" <fields: Comma<EnumFieldDecl>> ")" <ty: Type?> ";" => Box::new(EnumDeclare::new(name, ty, fields)),
}

EnumFieldDecl: EnumField = {
    <name: "IDENTIFIER"> => EnumField::new(name, None),
    <name: "IDENTIFIER"> ":=" <value: "LITERAL"> => EnumField::new(name, Some(value)),
}

/// Type
Type: Arc<Box<dyn Type>> = {
    "INT" => Arc::new(Box::new(IntType::new())),
    "IDENTIFIER" => Arc::new(Box::new(UserType::from_name(<>))),
}

/// Variable declare groups flat
VariableDeclareFactor: Vec<Arc<Variable>> = {
    VariableDeclareGroup,
    <mut v: VariableDeclareFactor> <mut e: VariableDeclareGroup> => { v.append(&mut e); v }
}

/// Single variable declare group, constain a list of same scope variable
VariableDeclareGroup: Vec<Arc<Variable>> = {
    VariableDeclareGroupStart VariableDeclareGroupAnnotation? "END_VAR" => vec![],
    <g: VariableDeclareGroupStart> <anno: VariableDeclareGroupAnnotation?> <v: VariableDeclareList> "END_VAR" => VariableDeclareGroup::new(g, anno, v),
}

VariableDeclareGroupStart: VariableScopeClass = {
    "VAR" => VariableScopeClass::None,
    "VAR_GLOBAL" => VariableScopeClass::Global,
    "VAR_INPUT" => VariableScopeClass::Input,
    "VAR_INOUT" => VariableScopeClass::InOut,
    "VAR_OUTPUT" => VariableScopeClass::Output,
    "VAR_TEMP" => VariableScopeClass::Temp,
    "VAR_STAT" => VariableScopeClass::Static,
}

VariableDeclareGroupAnnotation: VariableAnnotationFlags = {
    "RETAIN" => VariableAnnotationFlags::RETAIN,
    "PERSISTENT" => VariableAnnotationFlags::PERSISTENT,
    "RETAIN" "PERSISTENT" => VariableAnnotationFlags::RETAINPERSISTENT,
    "PERSISTENT" "RETAIN" => VariableAnnotationFlags::RETAINPERSISTENT,
}

/// A list of same scope varaible
VariableDeclareList: Vec<Arc<Variable>> = {
    MultiVariableDeclareStatement,
    VariableDeclareStatement => vec![<>],
    <mut v: VariableDeclareList> <e: VariableDeclareStatement> => { v.push(e); v },
    <mut v: VariableDeclareList> <mut e: MultiVariableDeclareStatement> => { v.append(&mut e); v }
}

/// Single variable declare
VariableDeclareStatement: Arc<Variable> = {
    <ident: "IDENTIFIER"> ":" <ty: Type> ";"  => Arc::new(Variable::with_type(<>)),
}

/// Multiple variable declare in one statement
MultiVariableDeclareStatement: Vec<Arc<Variable>> = {
    <ident_list: Comma<"IDENTIFIER">> ":" <ty: Type> ";" => Variable::multiple_variable_with_type(<>),
}